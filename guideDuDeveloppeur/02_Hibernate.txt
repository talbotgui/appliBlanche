# Règles de développement Hibernate

## Lazy loading
Toutes les associations doivent êtes *lazy*. Les *xxToMany* le sont par défaut donc il est inutile de le coder. 

Mais les *xxToOne* sont *eager* par défaut. Il faut donc ajouter *fetch=LAZY*

## Accesseurs

### Identifiant mono-colonne
Ne jamais implémenter le setter de l'identifiant unique. Au mieux, prévoir un constructeur comprenant l'identifiant. Ceci pour éviter les tentatives malheureuses de modification manuelle de l'identifiant d'une entité déjà persistée.

### Identifiant multi-colonne
Dans les classes définissant un identifiant unique (marquée *@Embeddable* et utilisée avec un *@Id* dans un *@Entity*), aucun setter ne doit exister. Seul le constructeur doit permettre d'initialiser les valeurs.

### Mutabilité
Tous les accesseurs doivent gérer la mutabilité des membres. Autrement dit, si le membre est de type *Date* ou *Collection*, il doit être cloné dans les deux accesseurs en utilisant *MutableUtils.getMutable*. La gestion des objets mutables n'empêche pas le chargement à la volée. 

Pour permettre d'ajouter ou de retirer un élément à une collection qui n'est pas en lecture seule (*mappedBy="xxx"* ou *updatable=false*), il faut ajouter des méthodes *addXxx* et *removeXxx*.

## @ManyToMany
Tous les @ManyToMany doivent être en lecture seule (*insertable=false* et *updatable=false*).
Il est plus simple de créer une entité mappée sur la table de jointure pour modifier les liens de cette associations.
Attention, pour la classe d'association, il est nécessaire de préciser le nom de la table avec *@javax.persistence.Table*. Sinon Hibernate pense que c'est une erreur et lance une exception *org.hibernate.tool.schema.spi.SchemaManagementException: SQL strings added more than once for: nom_table_en_double*.
Pour les détails d'un mapping *@ManyToMany* en lecture seule, se référer aux supports de la formation Hibernate.

## Repository

### Requête
Le principal outil pour faire des requêtes est *HQL*. L'usage de l'API *Criteria* est réservé aux cas les plus complexes (car cette API est plus complexe à utiliser et donc à maintenir).

### ReadOnly
L'usage de requêtes retournant des entités en lecture seule est à privilégier au maximum.
Dans un repository Spring-Data, il suffit d'ajouter à une méthode : 
``` @QueryHints(value = { @QueryHint(name = org.hibernate.jpa.QueryHints.HINT_READONLY, value = "true") }) ```


Dans une méthode utilisant l'API JPA, il faut utiliser la méthode *setHint* de *Query* :
``` em.createQuery(hql).setHint(org.hibernate.jpa.QueryHints.HINT_READONLY, true)```

Dans une méthode utilisant l'API Hibernate, il faut utiliser la méthode *setReadonly* de *Query* :
``` session.createQuery(hql).setReadonly(true)```
